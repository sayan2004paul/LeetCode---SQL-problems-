175. Combine Two Tables :

Write a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.
Return the result table in any order.

Soln :

SELECT 
 p.firstName , p.lastName,a.city ,a.state
FROM 
 Person p 
  LEFT JOIN 
   Address a 
    ON p.personId=a.personId




176. Second Highest Salary :
Write a solution to find the second highest distinct salary from the Employee table. If there is no second highest salary, return null (return None in Pandas).


Soln :

SELECT IFNULL((SELECT 
  DISTINCT salary  
  FROM 
   Employee 
    ORDER BY 
     salary DESC
      LIMIT 1 OFFSET 1),null) AS SecondHighestSalary


Optimised :

SELECT 
    MAX(salary) AS SecondHighestSalary
FROM (
    SELECT DISTINCT salary 
    FROM Employee 
    ORDER BY salary DESC 
    LIMIT 2
) AS temp
OFFSET 1;





177. Nth Highest Salary -Write a solution to find the nth highest distinct salary from the Employee table. If there are less than n distinct salaries, return null.



  

 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT 
BEGIN
 SET N=N-1;
 RETURN (
SELECT 
 DISTINCT salary 
  FROM Employee 
   ORDER BY salary DESC 
    LIMIT 1 OFFSET N
    );
    END 


178. Rank Scores - Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:

The scores should be ranked from the highest to the lowest.
If there is a tie between two scores, both should have the same ranking.
After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.
Return the result table ordered by score in descending order.



SELECT 
 score , DENSE_RANK()OVER(ORDER BY score DESC) AS 'rank' 
   FROM 
    Scores 



180. Consecutive Numbers - Find all numbers that appear at least three times consecutively.

SELECT 
 DISTINCT a.num AS 'ConsecutiveNums'
 FROM 
  Logs a , Logs b , Logs c 
   WHERE 
    a.id - b.id=1 AND b.id-c.id=1 AND a.num=b.num AND c.num=b.num


OPTIMISED - 

SELECT 
DISTINCT a.num AS 'ConsecutiveNums'
 FROM 
  Logs a 
   JOIN 
    Logs b ON b.id-a.id=1
     JOIN Logs c ON c.id-b.id=1
      WHERE  
       a.num=b.num 
        AND c.num=b.num


181. Employees Earning More Than Their Managers - Write a solution to find the employees who earn more than their managers.

WITH CTE AS (SELECT 
 b.name AS 'emp',b.salary AS 'emp_sal' , a.name AS 'mang' , a.salary AS 'mng_sal'
FROM 
  Employee a 
   JOIN Employee b 
    ON b.managerId =a.id )

    SELECT 
     emp AS 'Employee'
      FROM CTE 
       WHERE 
        emp_sal>mng_sal


182. Duplicate Emails - Write a solution to report all the duplicate emails. Note that it's guaranteed that the email field is not NULL.

SELECT 
  email AS 'Email'
 FROM 
  (
   SELECT DISTINCT email,COUNT(email) AS cnt 
    FROM Person 
     GROUP BY 
      email
)  a

WHERE 
 cnt>1


optimised :

Select 
 email 
 FROM Person 
 GROUP BY email 
 HAVING COUNT(*)>1



183. Customers Who Never Order - Write a solution to find all customers who never order anything.

SELECT 
c.name AS 'Customers'
 FROM 
  Customers c 
   LEFT JOIN Orders o 
    ON c.id=o.customerId
     WHERE 
      o.customerId IS NULL


184. Department Highest Salary : Write a solution to find employees who have the highest salary in each of the departments.

# Write your MySQL query statement below
WITH CTE AS (SELECT 
 d.name AS 'dept' , e.name AS 'emp' , e.salary  
 FROM 
  Employee e 
   JOIN 
    Department d 
     ON e.departmentId=d.id),

     CTE1 AS (SELECT 
      dept , emp , salary , DENSE_RANK()OVER(PARTITION BY dept ORDER BY salary DESC) AS rnk 
      FROM CTE )
       
       SELECT 
        dept AS 'Department' , emp AS 'Employee',salary AS 'Salary'
         FROM CTE1 
          WHERE 
           rnk=1

optimised :

WITH Ranked AS (
    SELECT 
        d.name AS Department,
        e.name AS Employee,
        e.salary AS Salary,
        DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS rnk
    FROM Employee e
    JOIN Department d ON e.departmentId = d.id
)
SELECT Department, Employee, Salary
FROM Ranked
WHERE rnk = 1;



185. Department Top Three Salaries - A company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department.
Write a solution to find the employees who are high earners in each of the departments.

WITH CTE AS (SELECT d.name AS 'dept', e.name AS 'emp',  e.salary AS 'salary' , DENSE_RANK()OVER(PARTITION BY d.name ORDER BY  e.salary DESC ) AS 'rnk'
FROM 
 Employee e 
  JOIN 
   Department d 
    ON e.departmentId=d.id)

    SELECT 
     dept AS 'Department',emp AS 'Employee',salary AS 'Salary'
      FROM CTE 
       WHERE 
        rnk <=3








196. Delete Duplicate Emails - Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id.
For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one.
For Pandas users, please note that you are supposed to modify Person in place.
After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter.



DELETE 
 FROM 
  Person 
   WHERE id NOT IN 
    (
        SELECT * FROM (

            SELECT MIN(id)
             FROM 
              Person 
               GROUP BY 
                email) a
        )


Facebook - Active User Retention (Assume you're given a table containing information on Facebook user actions. Write a query to obtain number of monthly active users (MAUs) in July 2022, including the month in numerical format "1, 2, 3".

Hint:

An active user is defined as a user who has performed actions such as 'sign-in', 'like', or 'comment' in both the current month and the previous month.)

WITH CTE AS (SELECT 
a.user_id , b.event_type AS curr_evnt , b.event_date AS curr_date,
 a.event_type AS prev_evnt , a.event_date AS prev_date
 
 FROM 
  fb_user_activity a 
   JOIN 
    fb_user_activity b 
     ON a.user_id=b.user_id AND MONTH(b.event_date)-MONTH(a.event_date)=1
   WHERE 
    MONTH(b.event_date)=7 AND YEAR(b.event_date)=2022)
     
     
     SELECT 
      MONTH(curr_date) AS month , COUNT(user_id) AS  monthly_active_users
       FROM CTE 
        WHERE 
         curr_evnt IN ('sign-in','like','comment' )
          AND 
           prev_evnt IN  ('sign-in','like','comment' )
           GROUP BY 
             MONTH(curr_date)
            

197. Rising Temperature - Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).

SELECT w1.id AS id  
 FROM 
  Weather w1 
   JOIN 
    Weather w2 
     ON 
      DATEDIFF(w1.recordDate,w2.recordDate)=1 
       WHERE 
        w1.temperature>w2.temperature

(imp)262. Trips and Users - The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.
Write a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between "2013-10-01" and "2013-10-03" with at least one trip. Round Cancellation Rate to two decimal points.


SELECT 
request_at AS Day ,
 ROUND((SUM(CASE 
  WHEN t.status  IN ('cancelled_by_driver','cancelled_by_client') THEN 1 ELSE 0 END)/COUNT(*)),2) AS 'Cancellation Rate' 
 FROM 
  Trips t 
   JOIN Users u1 
    ON t.client_id=u1.users_id AND u1.banned='No' AND u1.role='client'
     JOIN Users u2 
      ON t.driver_id=u2.users_id AND u2.banned='No' AND u2.role='driver'
       WHERE 
        request_at >='2013-10-01' AND request_at<='2013-10-03'
         GROUP BY 
          request_at 
  



511. Game Play Analysis I - Write a solution to find the first login date for each player.
Return the result table in any order.

SELECT 
 player_id , MIN(event_date) AS first_login
FROM 
 Activity 
  GROUP BY 
   player_id


512. Game Play Analysis II - Write a SQL query that reports the device that is first logged in for each player.

WITH CTE AS (SELECT 
 player_id , device_id , event_date , 
 DENSE_RANK()OVER(PARTITION BY player_id ORDER BY event_date) AS rnk 
  FROM 
   Activity )
   
   SELECT 
    player_id , device_id 
     FROM 
      CTE 
       WHERE 
        rnk=1






WAYFAIR - Y-on-Y Growth Rate -  This is the same question as problem #32 in the SQL Chapter of Ace the Data Science Interview!

Assume you're given a table containing information about Wayfair user transactions for different products. Write a query to calculate the year-on-year growth rate for the total spend of each product, grouping the results by product ID.

The output should include the year in ascending order, product ID, current year's spend, previous year's spend and year-on-year growth percentage, rounded to 2 decimal places.




WITH CTE AS (SELECT 
 YEAR(transaction_date) AS year ,product_id , SUM(spend) AS curr_year_spend, 
  LAG(SUM(spend)) OVER(PARTITION BY product_id ORDER BY  YEAR(transaction_date)) AS prev_year_spend
FROM 
 user_transactions
  GROUP BY 
    YEAR(transaction_date),  product_id 
  ORDER BY 
   YEAR(transaction_date) )
   
   
    SELECT 
     year , product_id , curr_year_spend ,prev_year_spend ,
      ROUND(((curr_year_spend- prev_year_spend)/(prev_year_spend))*100,2) AS yoy_rate 
       FROM 
        CTE 
        
     



534. Game Play Analysis III : (cumulative total)


SELECT 
 player_id , event_date ,games_played ,  SUM(games_played)
  OVER(PARTITION BY player_id  ORDER BY event_date 
   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW )AS games_played_so_far 
 FROM 
  Activity 
   GROUP BY
    player_id , event_date , games_played 
    


550. Game Play Analysis IV : (good)


WITH fl AS (SELECT 
 player_id , MIN(event_date) AS first_log 
  FROM 
   Activity 
    GROUP BY 
     player_id )

   SELECT 
    ROUND((SUM(DATEDIFF(a.event_date,f.first_log)=1))/(COUNT(DISTINCT a.player_id)),2) AS fraction
    FROM 
     fl  f 
      JOIN 
       Activity  a ON  f.player_id=a.player_id 
 
